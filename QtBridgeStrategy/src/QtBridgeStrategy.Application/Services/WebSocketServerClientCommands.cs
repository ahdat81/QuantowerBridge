using System.Collections.Generic;
using System;
using QtBridgeStrategy.Enums;
using QtBridgeStrategy.Models;
using QtBridgeStrategy.Services.Brokers;
using TradingPlatform.BusinessLayer;
using System.Text.Json;
using QtBridgeStrategy.Logging;
using System.Linq;
using System.Threading.Tasks;

namespace QtBridgeStrategy.Services
{
    /// <summary>
    /// Implementations of client requested commands
    /// </summary>
    public class WebSocketServerClientCommands
    {
        private OrderMgr _orderMgr;
        private Broker _broker;
        private Logger _log;
        private Core _core;

        private List<string> _subscribedSymbols = new List<string>();
        private bool _sendSymbolPricesOnNextInterval = false;
        private bool _flattening;

        private Dictionary<Command, Func<int, string, string[], string>> CommandMap;

       /// <summary>
       /// Constructor.  Creates a function map.
       /// </summary>
       /// <param name="qtStrategy"></param>
        public WebSocketServerClientCommands(QtBridgeStrategy qtStrategy) 
        {
            _broker = qtStrategy.Broker;
            _orderMgr = _broker.OrderMgr;
            _log = qtStrategy.Log;
            _core = qtStrategy.CoreRef;

            CommandMap = new Dictionary<Command, Func<int, string, string[], string>>
            {
                {Command.Ping, Ping },
                { Command.IsConnected, IsConnected },
                { Command.Disconnect, Disconnect },
                { Command.SubSymbolPrice, SubSymbolPrice },
                { Command.UnsubSymbolPrice, UnsubSymbolPrice },
                { Command.GetSymbolInfo, GetSymbolInfo },
                { Command.PlaceOrder, PlaceOrders },
                { Command.ModifyOrder, ModifyOrder },
                { Command.CancelOrder, CancelOrder},
                //{ Command.Flatten, Flatten }, // exception, has to be called differently so we cant add to map
                { Command.Init, Init },
                { Command.ReplaceOrder, ReplaceOrder },
            };
        }

        /// <summary>
        /// Executes the requested command
        /// </summary>
        /// <param name="command"></param>
        /// <param name="commandId"></param>
        /// <param name="callId">id generated by the client, to be sent back</param>
        /// <param name="args">information for the invoked command</param>
        /// <returns></returns>
        public async Task<string> CallCommand(Command command, int commandId, string callId, string[] args)
        {
            string res = "";
            // call execeptions to map
            if (command == Command.Flatten)
                res = await Flatten(commandId, callId, args);
            else // use map
                res = CommandMap[command](commandId, callId, args);
            return res;
        }

        /// <summary>
        /// Flatten orders
        /// </summary>
        /// <param name="command"></param>
        /// <param name="callId"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        public async Task<string> Flatten(int command, string callId, string[] args)
        {
            if (!_flattening)
                return "";

            try
            {
                _flattening = true;
                string targetSymbol = args[3];
                await _orderMgr.FlattenOrdersAndPositions(targetSymbol);
                return string.Format("<@|{0}|{1}|{2}|@>", (int)Command.Flatten, callId, targetSymbol);
            }
            catch (Exception ex)
            {
                _log.Ex(ex, "FlattenOrder");
            }
            finally
            {
                _flattening = false;
            }
            return "";
        }

        /// <summary>
        /// Ping request
        /// </summary>
        /// <param name="command"></param>
        /// <param name="callId"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        private string Ping(int command, string callId, string[] args)
        {
            return null;
        }

        /// <summary>
        /// Client calls after opening a connection
        /// </summary>
        /// <param name="command"></param>
        /// <param name="callId"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        private string Init(int command, string callId, string[] args)
        {
            return string.Format("<@|{0}|{1}|ok|@>", command, callId);
        }

        /// <summary>
        /// Sends back ok response
        /// </summary>
        /// <param name="command"></param>
        /// <param name="callId"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        private string IsConnected(int command, string callId, string[] args)
        {
            return string.Format("<@|{0}|{1}|ok|@>", command, callId);
        }

        /// <summary>
        /// Client request to disconnect.  Not implemented.
        /// </summary>
        /// <param name="command"></param>
        /// <param name="callId"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        private string Disconnect(int command, string callId, string[] args)
        {
            return string.Format("<@|{0}|{1}|ok|@>", command, callId);
        }

        /// <summary>
        /// Subscribe to getting price for specified symbols
        /// </summary>
        /// <param name="command"></param>
        /// <param name="callId"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        private string SubSymbolPrice(int command, string callId, string[] args)
        {
            string symbolsStr = args[3];
            var symbols = symbolsStr.Split(',');
            foreach (var symbol in symbols)
            {
                if (!_subscribedSymbols.Contains(symbol))
                {
                    _subscribedSymbols.Add(symbol);
                    _sendSymbolPricesOnNextInterval = true;
                }
            }
            return string.Format("<@|{0}|{1}|{2}|ok|@>", command, callId, symbolsStr);
        }

        /// <summary>
        /// UnSubscribe from getting price for specified symbols
        /// </summary>
        /// <param name="command"></param>
        /// <param name="callId"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        private string UnsubSymbolPrice(int command, string callId, string[] args)
        {
            string symbolsStr = args[3];
            var symbols = symbolsStr.Split(',');
            foreach (var symbol in symbols)
                _subscribedSymbols.RemoveAll(o => o == symbol);

            return string.Format("<@|{0}|{1}|{2}|ok|@>", command, callId, symbolsStr);
        }

        /// <summary>
        /// Request to get symbol information from Quantower
        /// </summary>
        /// <param name="command"></param>
        /// <param name="callId"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        private string GetSymbolInfo(int command, string callId, string[] args)
        {
            List<SymInfo> infos = new List<SymInfo>();
            // foreach (var sym in Broker.GetSymbols().Where(o => o != null && SymbolMap.ContainsValue(o.Root)))
            foreach (var sym in _broker.GetSymbols().Where(o => o != null))
            {
                infos.Add(new SymInfo
                {
                    symbol = _broker.GetSymbolName(sym),  // SymbolMap.First(o => o.Value == sym.Root).Key,
                    localSymbol = sym.Name,
                    description = sym.Description,
                    expirationDate = sym.ExpirationDate.ToShortDateString(),
                    tickSize = sym.TickSize
                    //tickAmount = sym.GetTickCost()
                }) ;
            }
            //string jsonStr = Newtonsoft.Json.JsonConvert.SerializeObject(infos);
            string jsonStr = JsonSerializer.Serialize(infos);
            return string.Format("<@|{0}|{1}|{2}|ok|@>", (int)Command.GetSymbolInfo, callId, jsonStr);
        }

        /// <summary>
        /// Modify order request
        /// </summary>
        /// <param name="command"></param>
        /// <param name="callId"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        private string ModifyOrder(int command, string callId, string[] args)
        {
            if (!_flattening)
                return "";

            List<string> orderJsonStrings = GetArgs(args, 3);
            string symbol = "";
            List<string> ids = new List<string>();

            //Log.Info("attempting to modify order");
            foreach (var orderJsonString in orderJsonStrings)
            {
                try
                {
                    if (string.IsNullOrEmpty(orderJsonString))
                        continue;

                    // execute order
                    BridgeOrderModification o = JsonSerializer.Deserialize<BridgeOrderModification>(orderJsonString);
                    _orderMgr.ModifyBridgeOrder(o, _broker.GetSymbol(o.symbol));

                    // update properties we'll need to send back with the response
                    ids.Add(o.id); 
                    symbol = o.symbol;
                }
                catch (Exception ex) 
                { 
                    _log.Ex(ex, "ModifyOrder"); 
                }
            }
            return string.Format("<@|{0}|{1}|{2}|{3}|@>", command, callId, ids.Aggregate((a, b) => a + "," + b), symbol);
        }

        /// <summary>
        /// CancelOrder request
        /// </summary>
        /// <param name="command"></param>
        /// <param name="callId"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        private string CancelOrder(int command, string callId, string[] args)
        {
            if (_flattening)
                return "";

            string symbol = ""; // Todo, this only handles order from same symbol
            List<string> ids = new List<string>();
            List<string> orderJsonStrings = GetArgs(args, 3);

            foreach (var orderJsonString in orderJsonStrings)
            {
                try
                {
                    if (string.IsNullOrEmpty(orderJsonString))
                        continue;

                    // execute order
                    BridgeOrderModification o = JsonSerializer.Deserialize<BridgeOrderModification>(orderJsonString);
                    string id = o.id;
                    _orderMgr.CloseOrderById(id, true);

                    // append properties, we'll need this for the response
                    symbol = o.symbol;
                    ids.Add(o.id);
                }
                catch (Exception ex) { _log.Ex(ex, "CancelOrder"); }
            }
            return string.Format("<@|{0}|{1}|{2}|{3}|@>", command, callId, ids.Aggregate((a, b) => a + "," + b), symbol);
        }

        /// <summary>
        /// Replace order request.  Not implemented.  May not be possible in quantower, may have to cancel and recreate.  But doing so automatically and introduce catastrophic issues.
        /// </summary>
        /// <param name="command"></param>
        /// <param name="callId"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        private string ReplaceOrder(int command, string callId, string[] args)
        {
            // Not supported
            return "";
            /*
            if (!flattening)
            {
                string symbol = ""; // Todo, this only handles order from same symbol
                List<string> ids = new List<string>();
                List<string> orderJsonStrings = new List<string>();
                for (int i = 3; i < args.Length; i++)
                    orderJsonStrings.Add(args[i]);

                foreach (var orderJsonString in orderJsonStrings)
                {
                    try
                    {
                        if (string.IsNullOrEmpty(orderJsonString))
                            continue;

                        //BridgeOrderModification o = new BridgeOrderModification();
                        //Newtonsoft.Json.JsonConvert.PopulateObject(orderJsonString, o);
                        BridgeOrderModification o = JsonSerializer.Deserialize<BridgeOrderModification>(orderJsonString);
                        string id = o.id;
                        symbol = o.symbol;
                        ids.Add(o.id);
                        if (IsGuid(o.id))
                        {
                            // is pre order, ignore
                            Log.Trade("replace failed, trying to replace a preorder");
                        }
                        else
                        {
                            Order order = Core.GetOrderById(o.id);
                            Log.Trade("replace order for " + order.Symbol + ", " + order.Id.ToString() + "... ");

                            OrderInfoAdditional infos = OrderMgr.GetAdditionalInfo(order);

                            // TODO does attached order also cancel?  if not we need to do that
                            // TODO should we also find the other order and do this as well?
                            var res = order?.Cancel();
                            await Task.Delay(500);
                            var msg = res.Status + " " + res?.Message ?? "";
                            Log.Trade("replace order, cancel order for " + order.Symbol + ", " + order.Id.ToString() + ". " + msg);
                            if (res.Status == TradingOperationResultStatus.Failure)
                            {
                                Log.Error("replace order, cancellation failed.  order recreation aborted.");
                            }
                            else
                            {
                                Log.Info("re placing order...");
                                var sym = order.Symbol;

                                // stop lost order is not correct.  do i need to modify an existing order?
                                var request = new PlaceOrderRequestParameters
                                {
                                    Account = Core.Instance.Accounts[0],
                                    Side = order.Side,
                                    StopLoss = SlTpHolder.CreateSL(CalcTicks(sym, order.Side, infos.ogEntry, infos.ogStop, "stop"), PriceMeasurement.Absolute, false, order.TotalQuantity, 0, true),
                                    TakeProfit = SlTpHolder.CreateTP(CalcTicks(sym, order.Side, infos.ogEntry, infos.ogTarget, "target"), PriceMeasurement.Absolute, order.TotalQuantity, 0, true),
                                    //Price = order.entry,
                                    Quantity = order.TotalQuantity,
                                    TimeInForce = TimeInForce.GTC,
                                    OrderTypeId = OrderType.StopLimit,//(orderType == 0 || order.orderType == 1) ? OrderType.Market : ((order.orderType == 2 || order.orderType == 3) ? OrderType.Limit : OrderType.StopLimit),
                                    Symbol = sym,
                                    Comment = order.Comment,
                                };

                                res = Core.PlaceOrder(request);
                                msg = res.Status + " " + res?.Message ?? "";
                                if (res.OrderId != null)
                                    Log.Trade("re place order for " + sym + ", " + res.OrderId.ToString() + ". " + msg);
                                else
                                    Log.Trade("re place order for " + sym + ", " + msg);
                            }
                        }
                    }
                    catch (Exception ex) { Log.Ex(ex, "ReplaceOrder"); }
                }
                responseCommand = string.Format("<@|{0}|{1}|{2}|{3}|@>", command, callId, ids.Aggregate((a, b) => a + "," + b), symbol);
            }*/
        }

        /// <summary>
        /// Place new orders
        /// </summary>
        /// <param name="command"></param>
        /// <param name="callId"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        private string PlaceOrders(int command, string callId, string[] args)
        {
            if (_flattening) // dont allow new orders while flattening
                return "";

            List<string> orderJsonStrings = GetArgs(args, 3);
            BridgeOrderResponse responseBuilder = new BridgeOrderResponse();
            Account account = GetAccount();
            responseBuilder.account = account.Id;

            int count = 0;
            foreach (var orderJsonString in orderJsonStrings)
            {
                try
                {
                    if (string.IsNullOrEmpty(orderJsonString))
                        continue;

                    // execute order
                    BridgeOrder order = JsonSerializer.Deserialize<BridgeOrder>(orderJsonString);
                    _orderMgr.ExecuteBridgeOrder(order, count, _broker, responseBuilder);
                }
                catch (Exception ex) { _log.Ex(ex, "PlaceOrder"); }
                count++;
            }

            return string.Format("<@|{0}|{1}|{2}|@>", command, callId, JsonSerializer.Serialize(responseBuilder));
        }

        /// <summary>
        /// Get first (and only?) account Quantower is connected to 
        /// </summary>
        /// <returns></returns>
        private Account GetAccount()
        {
            return _core.Accounts[0];
        }

        /// <summary>
        /// Helper class to return specified aruguments from the starting index
        /// </summary>
        /// <param name="args"></param>
        /// <param name="startIndex"></param>
        /// <returns></returns>
        private List<string> GetArgs(string[] args, int startIndex)
        {
            List<string> orderJsonStrings = new List<string>();
            for (int i = startIndex; i < args.Length; i++)
                orderJsonStrings.Add(args[i]);
            return orderJsonStrings;
        }
    }
}
